[MindMap](./Heap.png)
[demo](./Heap.cpp)


# 数据结构笔记：堆 (Heap)

## 1. 定义及类型
堆是一种**特殊的完全二叉树**，它满足堆性质：树中每个节点的值都不小于（或不大于）其左右孩子节点的值。

* **完全二叉树 (Complete Binary Tree)**: 除了最后一层外，其他层的节点数都达到最大，且最后一层的节点都连续集中在最左边。
* **大顶堆 (Max Heap)**: 任意节点的值 $\ge$ 其子节点的值。堆顶（Root）是最大元素。
* **小顶堆 (Min Heap)**: 任意节点的值 $\le$ 其子节点的值。堆顶（Root）是最小元素。

## 2. 存储与表示
由于完全二叉树的性质，堆通常使用**动态数组 (std::vector)** 顺序存储，不需要指针，节省空间且缓存友好。

对于数组中索引为 $i$ 的节点（索引从 0 开始）：
* **父节点索引**: $parent(i) = \lfloor \frac{i - 1}{2} \rfloor$
* **左孩子索引**: $left(i) = 2i + 1$
* **右孩子索引**: $right(i) = 2i + 2$

## 3. 核心操作与代码实现原理

### 3.1 核心调整算法
堆的所有操作都依赖于两个核心动作来维护堆性质：

1.  **上滤 (Sift Up / Swim)**:
    * **场景**: 新元素入堆。
    * **逻辑**: 将新节点与其父节点比较，如果违背堆性质（如大顶堆中子 > 父），则交换。重复直到满足性质或到达根节点。
    * **复杂度**: $O(\log n)$ (树的高度)。

```cpp
/* 从节点 i 开始，从底至顶堆化 */
void siftUp(int i) {
    while (true) {
        // 获取节点 i 的父节点
        int p = parent(i);
        // 当“越过根节点”或“节点无须修复”时，结束堆化
        if (p < 0 || maxHeap[i] <= maxHeap[p])
            break;
        // 交换两节点
        swap(maxHeap[i], maxHeap[p]);
        // 循环向上堆化
        i = p;
    }
}
```

2.  **下滤 (Sift Down / Sink)**:
    * **场景**: 删除堆顶、建堆。
    * **逻辑**: 将当前节点与左右孩子中较大的那个（大顶堆）比较，如果违背性质则交换。重复直到满足性质或成为叶子节点。
    * **复杂度**: $O(\log n)$。

```cpp
/* 从节点 i 开始，从顶至底堆化 */
void siftDown(int i) {
    while (true) {
        // 判断节点 i, l, r 中值最大的节点，记为 ma
        int l = left(i), r = right(i), ma = i;
        if (l < size() && maxHeap[l] > maxHeap[ma])
            ma = l;
        if (r < size() && maxHeap[r] > maxHeap[ma])
            ma = r;
        // 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出
        if (ma == i)
            break;
        swap(maxHeap[i], maxHeap[ma]);
        // 循环向下堆化
        i = ma;
    }
}
```

### 3.2 常用接口
* **push (入堆)**: 元素尾部插入数组 -> 执行 `siftUp`。
* **pop (出堆)**: 交换堆顶与末尾元素 -> 删除末尾元素 -> 对新堆顶执行 `siftDown`。
* **top (访问)**: 直接返回数组首元素 `vec[0]`。

### 3.3 建堆操作 (Heapify)
这是面试和考试的重点，区分两种方式：

1.  **逐个插入 (Iterative Push)**:
    * 对空堆依次调用 `push`。
    * **时间复杂度**: $O(n \log n)$。
2.  **自下而上建堆 (Floyd's Algorithm)**:
    * 直接将数组视为完全二叉树。
    * 从**最后一个非叶子节点**（索引 $\frac{n}{2} - 1$）开始，倒序遍历到根节点（索引 0），对每个节点执行 `siftDown`。
    * **时间复杂度**: **$O(n)$**。
    * *原理*: 大部分节点在底层，下滤高度小；只有少量节点在顶层，下滤高度大。数学求和收敛于线性时间。

```cpp
/* 构造方法，根据输入列表建堆 */
MaxHeap(vector<int> nums) :maxHeap(nums)
{
    // 堆化除叶节点以外的其他所有节点
    for (int i = parent(size() - 1); i >= 0; i--) 
    {
        siftDown(i);
    }
}
```

## 4. C++ STL 支持
C++ 标准库提供了 `<queue>` 头文件中的 `std::priority_queue`。

* **默认**: `std::priority_queue<int>` 是**大顶堆**。
* **小顶堆写法**:
    ```cpp
    // 模板参数：类型，容器，比较器
    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;
    ```

## 5. 常见应用场景

### 5.1 堆排序 (Heap Sort)
1.  建堆 ($O(n)$)。
2.  不断执行 `pop` 操作，将堆顶元素与数组末尾交换，缩小堆范围。
3.  总复杂度 $O(n \log n)$，空间复杂度 $O(1)$ (原地排序)。

### 5.2 Top-K 问题 (获取最大的 K 个元素)
* **海量数据处理核心策略**:
    * 如果求**最大**的 K 个元素：维护一个大小为 K 的**小顶堆**。
    * 遍历数据，当新元素 > 堆顶时，替换堆顶并 `siftDown`。
    * 遍历结束后，堆中即为最大的 K 个元素。
* **优势**: 只需要 $O(K)$ 的内存空间，适合数据量大到无法一次读入内存的场景。