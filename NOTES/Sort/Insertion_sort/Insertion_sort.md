# 算法笔记：插入排序 (Insertion Sort)

## 1. 核心概念与工作原理

插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理类似于我们打扑克牌时整理手牌的过程。

**具体步骤：**

1. **构建有序序列**：将数组的第一个元素视为已经排序好的序列。
2. **未排序扫描**：取出下一个元素（称为"基准"或"key"），在已经排序的元素序列中从后向前扫描。
3. **移位与插入**：
* 如果该元素（已排序）大于新元素，将该元素向后移动一位。
* 重复该步骤，直到找到已排序的元素小于或者等于新元素的位置。
* 将新元素插入到该位置后。


4. **重复**：对剩余所有未排序元素重复上述步骤，直到所有元素均排序完毕。

## 2. 算法特性

根据思维导图及算法原理，插入排序具有以下关键特性：

### 复杂度分析

* **时间复杂度**：
* **最佳情况**：$O(n)$ 。当输入数组已经是升序排列时，只需进行 $n-1$ 次比较，无需移动元素。
* **最坏情况**：$O(n^2)$ 。当输入数组是降序排列时，每插入一个元素都要与前面的所有元素比较并移动。
* **平均情况**：$O(n^2)$ 。


* **空间复杂度**：$O(1)$ 。这是一种原地排序算法（In-place sort），只需要常数级的额外空间（用于存储key变量）。

### 自适应性 (Adaptability)

这是插入排序的一个重要特性。算法能够适应数据的初始状态。当遇到有序数据时，内层循环的插入操作会提前终止（break），不需要遍历整个已排序序列。这意味着对于"部分有序"的数组，插入排序的效率极高。

### 稳定性 (Stability)

插入排序是**稳定排序**。

* **定义**：如果待排序的序列中存在两个或两个以上具有相同关键字的记录，排序后这些记录的相对次序保持不变。
* **原因**：在插入排序中，只有当当前元素严格小于已排序元素时，已排序元素才会后移。如果遇到相等的元素，新元素会插入到该元素的后面，因此相对顺序不会改变。

## 3. 相比其他基础排序的优势

尽管插入排序的时间复杂度在很多情况下不如快速排序或归并排序，但在特定场景下它具有不可替代的优势：

### (1) 小数据量下的效率

* **对比快速排序**：虽然快速排序的平均复杂度是 $O(n \log n)$ ，但在数据量较小（通常 $n < 10$ 到 $20$ ）时，快速排序的递归调用和分区操作带来的额外开销（Overhead）较大。插入排序逻辑简单，没有递归开销，因此在小规模数据上往往比快速排序更快。这也是为什么许多标准库（如STL的`std::sort`）在底层处理小块数据时会切换到插入排序的原因。

### (2) 优于冒泡排序 (Bubble Sort)

虽然两者平均时间复杂度都是 $O(n^2)$ ，但插入排序通常更快：

* **操作代价**：冒泡排序基于"交换"（Swap），一次交换涉及 3 个单元操作（引入临时变量，三次赋值）。插入排序基于"赋值"（Assignment），一次数据移动只需要 1 个单元操作。
* **计算开销**：在相同比较次数下，插入排序的写内存次数通常远少于冒泡排序。

### (3) 优于选择排序 (Selection Sort)

* **最好情况**：选择排序无论数据是否有序，都需要遍历剩余部分寻找最小值，因此其最好、最坏、平均时间复杂度永远是 $O(n^2)$ 。而插入排序在数据基本有序时接近 $O(n)$ 。
* **稳定性**：选择排序是不稳定的（例如序列 `[5, 5, 2]`，第一轮交换会将第一个5换到最后），无法应用于多级排序场景（如先按分数排，同分按学号排）。插入排序的稳定性使其能胜任此类任务。

---

## 4. C++ 代码实现


```cpp
/*
 * 文件名: insertion_sort.cpp
 * 描述: 插入排序算法实现与测试
 * 对应知识点: 排序算法、时间复杂度、稳定性
 * 备注: 适用于小规模数据或基本有序的数据
 */

#include <iostream>
#include <vector>

// 打印数组的辅助函数
void printArray(const std::vector<int>& arr) {
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}

/**
 * 插入排序函数
 * @param arr 待排序的整数向量（引用传递，直接修改原数组）
 */
void insertionSort(std::vector<int>& arr) {
    int n = arr.size();
    
    // 从第二个元素开始遍历（下标为1），因为下标0默认已视为有序
    for (int i = 1; i < n; ++i) {
        int key = arr[i]; // 记录当前需要插入的元素
        int j = i - 1;    // j 指向已排序序列的最后一个元素

        // 核心逻辑：
        // 从后向前扫描已排序序列
        // 如果 arr[j] 大于 key，则将 arr[j] 向后移动一位
        // j >= 0 保证不越界
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j]; // 元素后移（赋值操作，比交换代价小）
            j--;                 // 继续向前比较
        }
        
        // 找到合适位置后，将 key 插入
        // 此时 j 停在比 key 小的元素上（或者 -1），所以插入位置是 j + 1
        arr[j + 1] = key;
    }
}

int main() {
    // 测试用例 1: 一般乱序数组
    std::vector<int> data = {12, 11, 13, 5, 6};
    
    std::cout << "原始数组: ";
    printArray(data);

    insertionSort(data);

    std::cout << "排序后数组: ";
    printArray(data);

    // 测试用例 2: 验证稳定性与自适应性（此处仅演示排序结果）
    // 这种接近有序的数组，插入排序效率极高
    std::vector<int> nearlySorted = {2, 3, 4, 5, 8, 7, 9}; 
    std::cout << "\n接近有序的数组: ";
    printArray(nearlySorted);
    
    insertionSort(nearlySorted);
    
    std::cout << "排序后: ";
    printArray(nearlySorted);

    return 0;
}

```

### 学习心得 (Summary)

1. **实现细节**：注意内层 `while` 循环的条件是 `arr[j] > key`。如果是 `arr[j] >= key`，虽然也能排序，但会破坏算法的**稳定性**，这是考研或面试中的常见陷阱。
2. **应用场景**：如果知道数据量很小（例如对班级里某个小组的成绩排序），或者数据已经被前面的流程处理得比较整齐了，优先选择插入排序而不是快速排序。