[MindMap](./Counting_sort.png)


作为计算机科学中的经典**非比较型排序算法**，理解计数排序的关键在于掌握“用空间换时间”的思想，以及“前缀和”在维持算法稳定性中的决定性作用。

总结中不仅拓展了前缀和的底层逻辑，还加入了一个在实际 C++ 开发中非常实用的技巧：**通过偏移量（Offset）来打破“仅限非负整数”的局限性**。

# 深入理解计数排序 (Counting Sort)

计数排序是一种非基于比较的排序算法，其核心思想是：**统计每个元素在输入数组中出现的次数，然后根据这些统计信息来确定每个元素在输出数组中的最终位置。** 这种算法彻底打破了比较排序 $O(n \log n)$ 的时间复杂度下限，能够达到惊人的线性时间复杂度。

## 一、 算法原理与实现进阶

思维导图中提到了两种实现方式，这正是从“玩具代码”到“工程代码”的跨越：

### 1. 简单实现（仅限非负整数且不保证稳定性）
* **逻辑**：找出数组最大值 `k`，开辟一个大小为 `k+1` 的计数数组 `count`。遍历原数组，将元素值作为 `count` 的索引，出现一次则 `count[arr[i]]++`。最后遍历 `count` 数组，按顺序展开写回原数组。
* **致命缺陷**：这种方法只是简单地“覆盖”了原数组，它丢失了原有元素的实体。如果我们在排序一组对象（比如按学生的成绩给学生排序），这种简单实现会把学生信息弄丢，且无法保证稳定排序。

### 2. 完整实现（利用前缀和，支持对象排序与稳定排序）
* **逻辑拆解**：
  1. **统计频率**：和简单实现一样，先统计每个数值出现的次数。
  2. **计算前缀和**：对 `count` 数组进行变形，使 `count[i] = count[i] + count[i-1]`。
     * **核心奥秘**：变形后的 `count[i]` 代表的是**小于等于 `i` 的元素共有多少个**。这个数字直接决定了元素 `i` 在排序后数组中的最终位置边界！
  3. **逆序回填（保证稳定性）**：从后向前遍历原数组，利用 `count` 数组找到该元素的位置，放入输出数组，并将 `count` 对应的值减 1。

---

## 二、 算法特性深度剖析

* **时间复杂度：$O(n + k)$**
  * $n$ 是数组长度，$k$ 是数据的取值范围（最大值与最小值之差）。
  * 算法只涉及几次线性的遍历（遍历原数组计数、遍历计数数组求前缀和、逆序遍历原数组回填），因此时间复杂度极低。
* **空间复杂度：$O(n + k)$ (非原地排序)**
  * 需要一个大小为 $k$ 的 `count` 数组来进行统计。
  * 完整实现中还需要一个大小为 $n$ 的 `output` 数组来暂存排序结果以保证稳定性。
* **稳定排序 (Stable)**
  * **由于在最终排入输出数组时，我们是“逆序”遍历原数组的**，这保证了相同值的元素，在原数组中靠后的，在输出数组中依然靠后。
* **非自适应排序**
  * 无论输入数据是有序还是完全逆序，计数排序执行的步骤和时间是固定的。

---

## 三、 局限性与工程应对策略

思维导图指出了计数排序的两个主要局限性，在实际 C++ 编程中，我们需要知道如何应对：

1. **“只适用于非负整数”的局限**
   * **工程破解法**：不需要局限于非负整数。我们可以找出数组中的最小值 `min_val`。然后把 `arr[i] - min_val` 作为计数数组的索引。这样所有的数都会被平移到非负整数区间，完美解决负数问题（见下方代码实现）。
2. **“适用于数据量大但数据范围小”的局限**
   * 如果数据极度分散（例如数组只有两个元素：1 和 1000000），我们需要开辟一个大小为 1000000 的数组来统计，极其浪费内存。对于这种情况，更适合使用**基数排序**或传统的**快速排序**。

---

## 四、 C++ 完整代码实现

这段代码采用了**前缀和**技术保证稳定性，并引入了**最小值偏移（Offset）**技巧，使其完美支持包含负数的整型数组。

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // 用于 std::max_element 和 std::min_element

using namespace std;

/**
 * @brief 计数排序 (完整稳定版)
 * @param arr 待排序的数组引用
 */
void countingSort(vector<int>& arr) {
    if (arr.empty()) return;

    // 1. 找出数组中的最大值和最小值
    // 寻找最小值是为了计算偏移量，从而支持负数并节省空间
    int max_val = *max_element(arr.begin(), arr.end());
    int min_val = *min_element(arr.begin(), arr.end());

    // 2. 确定计数数组的大小 (范围)
    int range = max_val - min_val + 1;
    vector<int> count(range, 0);
    vector<int> output(arr.size());

    // 3. 统计每个元素出现的频率
    // 注意：存入 count 数组时，统一减去 min_val 进行偏移
    for (int i = 0; i < arr.size(); ++i) {
        count[arr[i] - min_val]++;
    }

    // 4. 计算前缀和 (核心步骤：确定元素所在位置的边界)
    // count[i] 现在表示小于等于对应值的元素总个数
    for (int i = 1; i < count.size(); ++i) {
        count[i] += count[i - 1];
    }

    // 5. 逆序遍历原数组，填充输出数组 (保证稳定性的关键！)
    // 逆序遍历确保了值相同的元素，原数组中靠后的排在后面
    for (int i = arr.size() - 1; i >= 0; i--) {
        // 当前元素的值对应的 count 索引
        int count_index = arr[i] - min_val; 
        
        // count[count_index] - 1 就是该元素在有序数组中的下标
        output[count[count_index] - 1] = arr[i]; 
        
        // 该值已经放置了一个，所以数量减 1
        count[count_index]--; 
    }

    // 6. 将排好序的 output 数组的内容复制回原数组
    for (int i = 0; i < arr.size(); ++i) {
        arr[i] = output[i];
    }
}

int main() {
    // 测试用例包含负数和重复元素，验证偏移量和稳定性的有效性
    vector<int> data = {4, 2, -3, 2, 8, -3, 3, 1};
    
    cout << "排序前的数组: ";
    for (int num : data) {
        cout << num << " ";
    }
    cout << "\n";

    countingSort(data);

    cout << "排序后的数组: ";
    for (int num : data) {
        cout << num << " ";
    }
    cout << "\n";

    return 0;
}

```