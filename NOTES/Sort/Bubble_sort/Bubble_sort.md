# 数据结构与算法笔记：冒泡排序 (Bubble Sort)

## 1. 算法原理

冒泡排序是一种基础的**交换排序**算法。

* **核心思想**：通过重复遍历要排序的数列，依次比较两个相邻的元素。如果它们的顺序错误（例如要求从小到大排列，而前者比后者大），就将它们交换过来。
* **过程形象化**：遍历数列的工作是重复进行的，直到没有再需要交换的元素为止。在这个过程中，数值越大的元素会像“气泡”一样，通过交换慢慢“浮”到数列的顶端（即数组的末尾）。
* **操作步骤**：
1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个（因为已经排好序了）。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。



## 2. 算法特性分析

作为计算机专业的学生，必须掌握算法的时空复杂度和稳定性。

### 2.1 复杂度

* **时间复杂度**：
* **平均情况**：$O(n^2)$ 。需要进行双重循环。
* **最坏情况**：$O(n^2)$ 。当输入数据是反序时。
* **最好情况**：$O(n)$ 。当输入数据已经有序，且使用了标志位优化（见下文优化部分）时，只需遍历一次即可停止。


* **空间复杂度**：$O(1)$ 
* 。冒泡排序是**原地排序**（In-place sort），只需要常数级的额外空间用于临时变量交换。



### 2.2 稳定性

* **结论**：冒泡排序是**稳定排序**。
* **原因**：在比较相邻元素时，如果两个元素相等（$A == B$），我们一般不会进行交换（判定条件通常是 $A > B$ 才交换）。因此，相同元素在排序前后的相对位置保持不变。

## 3. 效率优化

基础的冒泡排序效率较低，针对其特性主要有两种优化策略：

### 优化一：标志位优化 (Flag)

* **问题**：如果某一趟遍历中没有发生任何交换，说明数组已经有序，后续的遍历是多余的。
* **解决**：设置一个 `bool` 类型的标志位（例如 `swapped`）。在每一趟开始前将其置为 `false`，如果发生交换则置为 `true`。若一趟结束后标志位仍为 `false`，直接跳出循环。

### 优化二：记录最后交换位置

* **问题**：数组尾部可能已经局部有序。例如 `[3, 4, 2, 1, 5, 6, 7, 8]`，后面的 `5, 6, 7, 8` 已经有序，不需要每次都遍历到 $n-1-i$ 的位置。
* **解决**：记录最后一次发生交换的位置。该位置之后的元素已经有序，下一趟排序只需扫描到这个位置即可。

## 4. C++ 代码实现

以下代码包含**基础版**和**综合优化版**，采用现代C++风格（使用 `std::vector` 和 `std::swap`）。

```cpp
/**
 * @file bubble_sort.cpp
 * @brief 冒泡排序算法实现 (基础版与优化版)
 * @date 2026-02-13
 */

#include <iostream>
#include <vector>
#include <algorithm> // for std::swap

// 打印数组的辅助函数
void printVector(const std::vector<int>& arr) {
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}

// ==========================================
// 版本 1: 基础冒泡排序 (Standard Bubble Sort)
// ==========================================
void bubbleSortBasic(std::vector<int>& arr) {
    int n = arr.size();
    // 外层循环控制排序趟数，共需 n-1 趟
    for (int i = 0; i < n - 1; ++i) {
        // 内层循环进行两两比较
        // 第 i 趟结束后，最后 i 个元素已经是有序的，不需要再比较
        for (int j = 0; j < n - 1 - i; ++j) {
            if (arr[j] > arr[j + 1]) {
                // 交换相邻元素
                std::swap(arr[j], arr[j + 1]);
            }
        }
    }
}

// ==========================================
// 版本 2: 优化冒泡排序 (Optimized Bubble Sort)
// 包含：标志位优化 + 记录最后交换位置
// ==========================================
void bubbleSortOptimized(std::vector<int>& arr) {
    int n = arr.size();
    // k 表示当前需要扫描到的最后位置，初始为 n-1
    int k = n - 1;
    // 记录最后一次交换的位置
    int lastSwapPos = 0;

    // 只要 k > 0 就继续循环
    while (k > 0) {
        bool isSwapped = false;
        lastSwapPos = 0;

        for (int j = 0; j < k; ++j) {
            if (arr[j] > arr[j + 1]) {
                std::swap(arr[j], arr[j + 1]);
                isSwapped = true;
                // 更新最后一次交换的位置
                lastSwapPos = j;
            }
        }

        // 优化点 1: 如果本趟没有发生交换，说明数组已有序，直接退出
        if (!isSwapped) {
            break;
        }

        // 优化点 2: 下一趟只需要扫描到最后一次交换的位置
        k = lastSwapPos;
    }
}

int main() {
    // 测试数据
    std::vector<int> data1 = {64, 34, 25, 12, 22, 11, 90};
    std::vector<int> data2 = {5, 1, 4, 2, 8, 0, 2};

    std::cout << "--- 基础版冒泡排序 ---" << std::endl;
    std::cout << "排序前: ";
    printVector(data1);
    bubbleSortBasic(data1);
    std::cout << "排序后: ";
    printVector(data1);

    std::cout << "\n--- 优化版冒泡排序 ---" << std::endl;
    std::cout << "排序前: ";
    printVector(data2);
    bubbleSortOptimized(data2);
    std::cout << "排序后: ";
    printVector(data2);

    return 0;
}

```