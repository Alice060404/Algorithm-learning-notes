[MindMap](./Radix_sort.png)


# 深入理解基数排序 (Radix Sort)

基数排序是一种非比较型整数排序算法。它的核心思想是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（如名字或日期）和特定格式的浮点数，所以基数排序并不局限于纯整数。

思维导图中给出的“典型案例：排序学号”非常贴切。学号通常是固定长度的数字串（如年份+学院代码+班级+个人序号），非常适合用基数排序来处理。

---

## 一、 算法原理与核心步骤

基数排序通常采用 **LSD (Least Significant Digit，最低有效位)** 方式。算法流程如下：

1. **寻找最大值，确定迭代次数**：遍历一次数组，找到最大值，获取其位数 $d$。这决定了我们需要进行多少轮外层循环。
2. **从最低位开始循环排序**：初始化当前位 $k = 1$（代表个位）。
3. **执行稳定排序**：对数组中所有元素的第 $k$ 位数字提取出来，并使用一种**稳定**的排序算法（通常是**计数排序**）对整个数组进行重排。4. **进位迭代**：将 $k$ 进阶到下一位（如十位、百位），重复步骤 3，直到最高位排序完成。

---

## 二、 核心探讨：为什么必须从最低位开始排序？

这是基数排序中最容易让人困惑，也是面试中最常被问到的问题。

* **如果从最高位开始 (MSD - Most Significant Digit)**：排完最高位后，数据被分成了几个大块。如果继续对次高位进行全局排序，次高位的排序结果会直接**打乱**最高位好不容易建立起来的顺序，导致最终结果完全错误。（注：MSD 实际上需要结合递归分治来实现，只在每个分块内部继续排次高位，这非常复杂，一般不用）。
* **从最低位开始 (LSD) 的精妙之处**：
  我们先根据个位排好序。然后根据十位排序时，如果两个数的十位相同，**因为内部使用的是“稳定排序算法”，它们在个位排序时建立的相对顺序会被完美保留下来。**
  
* **结论**：高位的权重天然大于低位。LSD 做法保证了高位排序的结果拥有绝对的决定权；而当高位数值相同时，低位的有序性依然生效。

---

## 三、 算法特性分析

* **时间复杂度：$O(d \times (n + k))$**
  * $n$ 是数组长度，$d$ 是最大值的位数（迭代次数），$k$ 是基数（对于十进制数，$k = 10$）。
  * 每一轮按位排序我们都调用了一次时间复杂度为 $O(n + k)$ 的计数排序，总共执行 $d$ 轮。
  * 当 $d$ 较小且为常数时，基数排序的时间复杂度可以近似看作线性的 $O(n)$。
* **空间复杂度：$O(n + k)$**
  * 由于底层依赖计数排序，需要额外的计数数组（大小为 $k$）和临时输出数组（大小为 $n$），因此是非原地排序。
* **稳定排序 (Stable)**
  * 基数排序的稳定性严格依赖于其内部按位排序所采用的算法。只要内部的计数排序是稳定的（采用前缀和与逆序回填机制），基数排序全局就是严格稳定的。
* **非自适应排序**
  * 无论输入数据是否有序，都会老老实实地从个位一直排到最高位，执行步骤完全一致。

---

## 四、 适用范围

* **固定长度的数据**：如手机号、身份证号、固定格式的学号、IP地址。
* **数据范围极大，但位数有限**：如果使用计数排序处理最大值为 1000 万的数组，需要 1000 万大小的空间。但如果用基数排序，对于 1000 万以内的数字，最多只需 8 次循环，每次循环只需要大小为 10 的计数数组（因为十进制每位只有 0-9），极大地节省了内存。

---

## 五、 C++ 完整代码实现

下面的代码实现了 LSD 基数排序。请注意其中 `countingSortForRadix` 函数的设计，它正是基于我们之前笔记中写过的“带有前缀和的稳定计数排序”，只是提取元素的逻辑变成了“提取特定位上的数字”。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

/**
 * @brief 专门为基数排序定制的计数排序子程序
 * @param arr 待排序的数组引用
 * @param exp 当前的指数 (1代表个位, 10代表十位, 100代表百位...)
 */
void countingSortForRadix(vector<int>& arr, int exp) {
    int n = arr.size();
    vector<int> output(n);
    // 基数是 10，因为十进制数字的每一位都在 0-9 之间
    vector<int> count(10, 0); 

    // 1. 统计当前位 (exp 所指的位) 上的数字出现次数
    for (int i = 0; i < n; i++) {
        // (arr[i] / exp) % 10 用于提取指定位上的数字
        int digit = (arr[i] / exp) % 10;
        count[digit]++;
    }

    // 2. 计算前缀和，确定元素在 output 数组中的末尾边界位置
    for (int i = 1; i < 10; i++) {
        count[i] += count[i - 1];
    }

    // 3. 逆序遍历原数组回填，保证排序的稳定性 (非常关键)
    for (int i = n - 1; i >= 0; i--) {
        int digit = (arr[i] / exp) % 10;
        output[count[digit] - 1] = arr[i];
        count[digit]--;
    }

    // 4. 将本次按位排序的结果复制回原数组
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }
}

/**
 * @brief 基数排序主控函数
 * @param arr 待排序的数组引用
 */
void radixSort(vector<int>& arr) {
    if (arr.empty()) return;

    // 1. 找到数组中的最大值，以确定需要排序多少位
    int max_val = *max_element(arr.begin(), arr.end());

    // 2. 从个位开始，对每一位进行计数排序
    // exp 依次为 1, 10, 100, 1000...
    for (int exp = 1; max_val / exp > 0; exp *= 10) {
        countingSortForRadix(arr, exp);
    }
}

int main() {
    // 模拟一组学号或大整数
    vector<int> studentIDs = {2023015, 2023002, 2022108, 2023011, 2022099, 2021005};
    
    cout << "排序前的学号数据: ";
    for (int id : studentIDs) {
        cout << id << " ";
    }
    cout << "\n";

    radixSort(studentIDs);

    cout << "基数排序后的学号: ";
    for (int id : studentIDs) {
        cout << id << " ";
    }
    cout << "\n";

    return 0;
}

```