[MindMap](./Heap_sort.png)


# 深入理解堆排序 (Heap Sort)

堆排序是一种基于比较的、利用“堆”这种特殊数据结构设计的高效排序算法。它可以被视为**选择排序的升级版**：选择排序每次在线性数组中遍历寻找最大值（时间复杂度 $O(n)$），而堆排序通过维护一个完全二叉树，将寻找最大值的时间复杂度降到了 $O(\log n)$。

## 一、 核心前置知识：数组与完全二叉树的逻辑映射

堆排序最巧妙的地方在于：**它不需要真正创建树结构的节点和指针**，而是直接在一个一维数组上进行原地操作。我们将数组按“层序遍历”的顺序，逻辑上映射为一棵完全二叉树。


对于一个长度为 $n$，起始下标为 $0$ 的数组，任意一个节点索引 $i$ 的树节点关系具有严格的数学推导：

* **父节点索引**： $\lfloor \frac{i - 1}{2} \rfloor$ (向下取整)
* **左子节点索引**： $2i + 1$
* **右子节点索引**： $2i + 2$

**关键推论**：在一个长度为 $n$ 的数组中，最后一个非叶子节点的索引必定是 $\lfloor \frac{n}{2} \rfloor - 1$。从 $\lfloor \frac{n}{2} \rfloor$ 到 $n-1$ 的所有节点，都是叶子节点。这个推论是“建堆”操作的时间复杂度能够优化的核心。

---

## 二、 算法核心动作拆解

堆排序的核心分为两个大阶段：**建堆**与**排序**。而贯穿始终的一个基础动作是**向下调整 (Sift Down / Heapify)**。

### 1. 基础动作：向下调整 (Sift Down)
* **目的**：当一个节点的值小于其子节点时，将其“下沉”，以修复以该节点为根的子树，使其重新满足大顶堆的性质。
* **过程**：将当前节点与其左右子节点进行比较，找出三者中的最大值。如果最大值不是当前节点，则将当前节点与最大值所在的子节点交换。交换后，被破坏的子层继续重复此过程，直到该节点大于等于其所有子节点，或已经沉到底部（成为叶子节点）。


### 2. 阶段一：建立大顶堆 (Build Max Heap)
* **错误直觉**：从前往后扫描数组建堆。
* **正确做法（自底向上）**：从**最后一个非叶子节点**（即索引 $\lfloor \frac{n}{2} \rfloor - 1$）开始，**从右向左、从下向上**，依次对每个节点执行一次 Sift Down 操作，直到根节点（索引 $0$）。
* **原理**：叶子节点天生就是一个合法的堆（因为它没有子节点）。我们从最底层的非叶子节点开始，逐步向上合并，保证在处理当前节点时，它的左右子树已经是合法的大顶堆了。

### 3. 阶段二：首尾交换与断开 (Sort)
* 完成建堆后，数组的第 $0$ 个元素（根节点）绝对是全局最大值。
* 将其与数组的最后一个元素交换。此时，最大值已经被放置到了正确的位置（数组末尾）。
* **断开**：逻辑上将数组长度减 $1$，把刚刚排好序的最大元素排除在堆外。
* **修复**：由于根节点被换成了一个较小的元素，大顶堆性质被破坏。对新的根节点（索引 $0$）执行一次 Sift Down 操作，重新选出剩余元素中的最大值。
* 重复此交换和修复过程，直到堆的大小缩小为 $1$。


---

## 三、 算法特性深度剖析

* **时间复杂度：严格的 $O(n \log n)$**
    * **建堆时间**：虽然看起来包含一个外层循环和内层的树高遍历，但实际上底层节点多且下沉距离短，高层节点少且下沉距离长。通过数学级数求和可以证明，建堆的时间复杂度是严格的 $O(n)$。这是一个非常经典的面试考点。
    * **排序时间**：需要进行 $n-1$ 次交换和下沉。每次下沉的最大深度为树的高度 $\log n$，因此排序阶段的时间复杂度为 $O(n \log n)$。
    * **总结**：堆排序不受输入数据初始状态的影响，最好、最坏、平均时间复杂度均为 $O(n \log n)$。

* **空间复杂度：$O(1)$ (原地排序)**
    * 仅需要几个额外的变量用于记录索引和交换，不需要开辟新的数组。如果使用迭代法实现 Sift Down，甚至不需要消耗递归调用栈的空间。

* **稳定性：非稳定排序 (Unstable)**
    * **原因**：在排序阶段，我们会将堆顶元素与堆底元素进行长距离的交换。
    * **反例**：假设数组为 `{5A, 5B, 3}`。建堆后可能依然是 `{5A, 5B, 3}`。第一轮排序交换首尾，变成 `{3, 5B, 5A}`。此时 $5A$ 被换到了最后。排序结束后，原本在前的 $5A$ 会排在 $5B$ 之后，相对顺序被破坏。

---

## 四、 C++ 代码实现

在实际工程中，为了追求极致的性能，避免递归带来的函数调用栈开销，`siftDown` 操作通常推荐使用**迭代 (while 循环)** 来实现。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include<utility> // 引入 std::swap

using namespace std;

/**
 * @brief 向下调整操作 (Sift Down) - 迭代版本
 * * @param arr  待排序的数组引用
 * @param n    当前堆的有效物理大小（动态缩小）
 * @param root 当前需要向下调整的父节点索引
 */
void siftDown(vector<int>& arr, int n, int root) {
    int current = root;
    
    // 当存在左子节点时，说明还没有沉到叶子节点，继续循环
    // 因为是完全二叉树，如果没有左子节点，就绝对不可能有右子节点
    while (2 * current + 1 < n) {
        int left = 2 * current + 1;
        int right = 2 * current + 2;
        int largest = current; // 默认当前节点为最大值

        // 1. 比较左子节点
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
    }

        // 2. 比较右子节点（需要确保右子节点没有越界）
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }

        // 3. 如果当前节点已经是最大的，说明满足大顶堆性质，停止下沉
        if (largest == current) {
            break; 
        }

        // 4. 否则，将最大值所在的子节点与当前节点交换位置
        swap(arr[current], arr[largest]);
        
        // 5. 更新 current 的索引，继续考察下一层
        current = largest;
    }
}

/**
 * @brief 堆排序主控函数
 * * @param arr 待排序的数组
 */
void heapSort(vector<int>& arr) {
    int n = arr.size();
    if (n <= 1) return; // 边界情况处理

    // 阶段一：建立大顶堆 (Build Max Heap)
    // 从最后一个非叶子节点 (n/2 - 1) 开始，逆序遍历到根节点 (0)
    for (int i = n / 2 - 1; i >= 0; i--) {
        siftDown(arr, n, i);
    }

    // 阶段二：排序 (Sort)
    // 每次将堆顶（最大值）交换到数组末尾，然后缩小堆的范围，重新调整剩余元素
    for (int i = n - 1; i > 0; i--) {
        // 将最大值放到已排序区域的最前端（即未排序区域的末尾）
        swap(arr[0], arr[i]);
        
        // 重新调整堆顶，此时堆的有效长度为 i
        siftDown(arr, i, 0);
    }
}

int main() {
    vector<int> data = {4, 10, 3, 5, 1, 9, 2};
    
    cout << "排序前的数组: ";
    for (int num : data) {
        cout << num << " ";
    }
    cout << "\n";

    heapSort(data);

    cout << "排序后的数组: ";
    for (int num : data) {
        cout << num << " ";
    }
    cout << "\n";

    return 0;
}

```

 对于建堆阶段的时间复杂度推导（为什么是 $O(n)$ 而不是 $O(n \log n)$），这涉及到一些级数求和的数学证明。

