# 选择排序 (Selection Sort) 学习笔记

## 1. 算法原理

选择排序是一种简单直观的排序算法。它的核心思想是将数组划分为**已排序区间**和**未排序区间**。

* **初始状态**：整个数组都是未排序区间，已排序区间为空。
* **排序过程**：
1. 每一次从**未排序区间**中找到最小（或最大）的元素。
2. 将该元素与**未排序区间**的第一个元素交换位置。
3. 此时，该元素归入**已排序区间**，未排序区间长度减 1。


* **终止条件**：当未排序区间只剩下一个元素时，排序结束。

**直观理解**：
就好比你要把一堆高低不平的扑克牌排好序，你每次都从剩下的牌里挑出一张最小的，放到已经排好的队伍末尾，直到挑完为止。

## 2. 算法特性

### 2.1 时间复杂度

* **平均时间复杂度**：$O(n^2)$
* **最坏时间复杂度**：$O(n^2)$
* **最好时间复杂度**：$O(n^2)$
* *注意*：无论数组原本是否已经有序，选择排序都需要遍历剩余的未排序元素来寻找最小值，因此其比较次数固定为 $n(n-1)/2$ 次，效率较低，不适合大规模数据。



### 2.2 空间复杂度

* **空间复杂度**：$O(1)$
* 只需要常数级别的额外空间（用于临时变量交换），属于**原地排序** (In-place Sort)。



### 2.3 稳定性 (重点拓展)

“非稳定性：相同元素的顺序可能发生改变”。这是一个非常重要的考点。

* **结论**：选择排序是**不稳定**的排序算法。
* **原因**：在交换操作中，如果当前未排序区间的首个元素（假设为 A）大于后续的某个元素（假设为 B），且在 A 和 B 之间存在与 A 值相同的元素（A'），那么 A 在与最小值交换到已排序区间末尾时，可能会被换到 A' 的后面，从而破坏了原有顺序。
* **举例说明**：
假设有一个序列：`[5, 8, 5, 2, 9]`
1. **第一轮**：在 `[5, 8, 5, 2, 9]` 中找到最小值 `2`。
2. **交换**：将 `2` 与第一个元素 `5` (记为 $5_a$ ) 交换。
3. **结果**：序列变为 `[2, 8, 5, 5, 9]`。
4. **分析**：此时原本在第一个位置的 $5_a$ 被换到了第三个位置的 $5_b$ 后面。原序列中 $5_a$ 在 $5_b$ 前面，现在顺序颠倒了，因此是不稳定的。



## 3. C++ 代码实现

以下代码采用了 C++ 标准库风格，使用了 `std::vector` 和 `std::swap`，并添加了详细注释方便复习。

```cpp
/**
 * @file selection_sort.cpp
 * @brief 选择排序算法实现 (C++版)
 * @note 适用于大一计算机基础课程复习，包含详细逻辑注释
 */

#include <iostream>
#include <vector>
#include <algorithm> // 用于 std::swap

// 打印数组的辅助函数
void printVector(const std::vector<int>& arr) {
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}

/**
 * @brief 选择排序函数
 * @param arr 待排序的 vector 引用
 */
void selectionSort(std::vector<int>& arr) {
    int n = arr.size();

    // 外层循环：控制已排序区间的边界
    // i 代表当前未排序区间的起始下标
    for (int i = 0; i < n - 1; ++i) {
        
        // 假设当前未排序区间的第一个元素是最小值
        int minIndex = i;

        // 内层循环：在未排序区间 [i+1, n-1] 中寻找真正的最小值
        for (int j = i + 1; j < n; ++j) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j; // 更新最小值的下标
            }
        }

        // 如果找到的最小值不是当前区间的第一个元素，则进行交换
        if (minIndex != i) {
            std::swap(arr[i], arr[minIndex]);
        }
        
        // 可选：打印每一轮排序后的状态，方便理解过程
        // std::cout << "第 " << i + 1 << " 轮排序结果: ";
        // printVector(arr);
    }
}

int main() {
    // 测试数据
    std::vector<int> data = {64, 25, 12, 22, 11};

    std::cout << "原始数组: \n";
    printVector(data);

    std::cout << "-----------------\n";

    // 执行排序
    selectionSort(data);

    std::cout << "排序后数组: \n";
    printVector(data);

    // 验证不稳定性示例 (手动验证逻辑用)
    // std::vector<int> unstableTest = {5, 8, 5, 2, 9};
    // selectionSort(unstableTest);
    
    return 0;
}

```

## 4. 总结

选择排序虽然实现简单，但由于 $O(n^2)$ 的时间复杂度和不稳定性，在实际工程中很少直接使用（除非数据量极小）。对于初学者来说，它主要是用来理解“查找最值”和“交换”这两个基本操作在算法中的组合应用。