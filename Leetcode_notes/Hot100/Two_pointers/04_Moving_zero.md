# LeetCode 283. 移动零 (Move Zeroes)

## 题目描述 [Original question](https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1：**
> 输入: nums = [0,1,0,3,12]
> 输出: [1,3,12,0,0]

**示例 2：**
> 输入: nums = [0]
> 输出: [0]

---

## 分析思路

这道题目的核心限制是**“原地操作 (In-place)”**，这意味着我们不能申请一个新的数组来存放排序后的结果，空间复杂度必须严格控制在 $O(1)$。

面对数组的原地修改问题，计算机科学中最常用的技巧是**双指针法 (Two Pointers)**。
我们需要在一次遍历中完成元素的筛选与位置交换。可以将数组划分为两个区域：
1. **已处理的非零元素区域**（在数组前端）。
2. **待处理的未探索区域**（在数组后端）。



我们的目标是随着遍历的进行，不断将非零元素扩充到前端区域，而将零元素“挤”到最后。

---

## 我的解法：零计数器与相对偏移

你提供的解法非常巧妙，是双指针思想的一种极佳变体。
你没有显式地定义两个独立的指针，而是通过记录**遇到的 0 的个数 (`numZero`)** 来计算当前非零元素应该放置的位置。

当遍历到索引 `i` 时的非零元素，它前面有 `numZero` 个零，所以它理应向前移动 `numZero` 个位置，即放到 `i - numZero` 处。通过 `swap` 操作，非零元素被前移，而零被后置。

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int numZero(0), n(nums.size());
        for (int i = 0; i < n; i++) {
            // 如果当前元素是 0，零计数器加一
            if (!nums[i]) ++numZero;
            // 如果是非零元素，将其与前面的 0 进行交换
            // i - numZero 恰好是当前最前面的 0 的索引
            else swap(nums[i], nums[i - numZero]);
        }
    }
};

```

* **时间复杂度：**$O(N)$ ，其中 $N$ 是数组的长度。只需要对数组进行一次线性遍历。
* **空间复杂度：**$O(1)$ ，仅使用了常数级别的额外变量。

---

## 其他经典解法

### 解法一：标准快慢双指针 (推荐)

这是教科书中最标准的双指针写法。定义一个慢指针 `left` 指向已处理好的非零元素序列的尾部，一个快指针 `right` 用于遍历整个数组。
每次 `right` 遇到非零元素时，就将其与 `left` 指向的元素交换，然后 `left` 向前走一步。

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int left = 0; // 指向下一个非零元素应该存放的位置
        for (int right = 0; right < nums.size(); right++) {
            if (nums[right] != 0) {
                swap(nums[left], nums[right]);
                left++;
            }
        }
    }
};

```

* **时间复杂度：**$O(N)$ 。
* **空间复杂度：**$O(1)$ 。
* **思路对比：** 你的解法中的 `i - numZero` 本质上就等同于这里的 `left` 指针。两者的核心逻辑是一致的，只是变量表达方式不同。

### 解法二：两次遍历（覆盖+补零）

这种思路不使用交换（`swap`），而是直接覆盖。
第一遍遍历，将所有非零元素按顺序依次放到数组的最前面。
第二遍遍历，将剩余的位置全部填充为 `0`。

```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int index = 0;
        // 第一步：把所有非零元素移到前面
        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] != 0) {
                nums[index++] = nums[i];
            }
        }
        // 第二步：把剩余的位置全部置为 0
        for (int i = index; i < nums.size(); i++) {
            nums[i] = 0;
        }
    }
};

```

* **时间复杂度：**$O(N)$ 。
* **空间复杂度：**$O(1)$ 。
* **缺点：** 虽然时间复杂度也是 $O(N)$ ，但如果数组中只有极少量的零（例如 `[0, 1, 2, 3, 4, 5]`），第一种解法无需交换或只需少量交换，而这种解法会将所有非零元素重新写入一遍，增加了内存写入操作的开销。

---

## 总结

| 解法 | 时间复杂度 | 空间复杂度 | 核心思想 | 优缺点分析 |
| --- | --- | --- | --- | --- |
| **零计数器法** (我的解法) | $O(N)$ | $O(1)$ | 记录偏移量，边查边交换 | 思维巧妙，代码极简，单次遍历完成。 |
| **快慢双指针** (经典解法) | $O(N)$ | $O(1)$ | 维护非零边界，边查边交换 | 最具普适性的双指针模板，易于理解和记忆。 |
| **两次遍历法** (覆盖补零) | $O(N)$ | $O(1)$ | 先集中非零，再集中补零 | 逻辑最直白，但在全是非零元素时会有冗余的写入操作。 |

**学习心得：**
作为计算机基础算法，"移动零" 是深刻理解 **数组内存连续性** 与 **指针偏移控制** 的试金石。通过对比 `swap` 交换和直接赋值覆盖的细微差别，能够培养出对程序底层内存读写操作（Memory R/W）开销的敏感度，这是向优秀 C++ 工程师进阶的必经之路。