# LeetCode 239. 滑动窗口最大值 (Sliding Window Maximum)

## 1\. 题目描述 [Original question](https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

**示例 1：**

```text
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

## 2\. 题目分析

这道题的核心诉求是：在一个动态变化的区间（窗口）内，快速找到最大值。

作为大一刚接触数据结构与算法的学生，最直观的想法可能是每次窗口滑动后，遍历窗口内的 `k` 个元素找最大值，但这会导致 $O(n \times k)$ 的时间复杂度，对于 LeetCode 的数据规模必然会导致超时（TLE）。

因此，我们需要一种数据结构来“记住”窗口内的状态。你需要一边添加新元素，一边移除旧元素，同时还要能高效查询当前最大值。优先队列（大根堆）是一个非常自然且优秀的切入点，它能够以对数时间复杂度维护最大值。

## 3\. 我的解法（优先队列 / 大根堆）

利用 C++ 标准库中的 `priority_queue` 维护一个大根堆。堆顶始终是最大值。为了判断堆顶元素是否已经滑出当前窗口，我们需要在堆中同时存储元素的值和它的索引。

### C++ 代码实现

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        // 存储 pair<数值, 索引> 的大根堆
        priority_queue<pair<int,int>> maxHeap;
        vector<int> MAX;
        int n = nums.size();
        
        for(int left = 0, right = 0; right < n; right++) {
            // 将当前元素及其索引压入堆中
            maxHeap.push({nums[right], right});
            
            // 窗口大小还不够 k，继续向右扩展
            if(right - left + 1 < k)
                continue;
                
            // 核心逻辑：如果堆顶元素（最大值）的索引已经不在当前窗口 [left, right] 内
            // 就将其弹出，直到堆顶元素在当前窗口内为止
            while(maxHeap.top().second < left) {
                maxHeap.pop();
            }
            
            // 此时堆顶元素一定是当前窗口的最大值
            MAX.push_back(maxHeap.top().first);
            left++; // 窗口左边界右移
        }
        return MAX;
    }
};
```

## 4\. 官方题解及分析（单调队列）

虽然优先队列的解法很好，但它的时间复杂度还有优化的空间。LeetCode 官方推荐的最优解法是使用**单调队列**（Monotonic Queue），这是一种在算法竞赛和面试中非常经典的技巧。

我们可以观察到一个规律：如果新进入窗口的元素比之前的元素大，那么之前的那些较小的元素就**永远不可能**成为后续窗口的最大值了。因此，我们可以直接将它们“丢弃”。

我们使用双端队列 `std::deque` 来存储元素的**索引**，并保持队列对应的元素值是**严格单调递减**的。队首始终是当前窗口的最大值索引。

### C++ 代码实现

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        deque<int> q; // 双端队列，存储的是元素的索引
        vector<int> ans;
        
        for (int i = 0; i < n; ++i) {
            // 1. 如果队首元素的索引已经滑出窗口（即 i - k >= 队首索引），将其从队首移出
            if (!q.empty() && q.front() <= i - k) {
                q.pop_front();
            }
            
            // 2. 保持队列的单调递减性质：
            // 如果新来的元素大于等于队尾元素对应的值，那么队尾元素永远不可能成为最大值，直接弹出
            while (!q.empty() && nums[q.back()] <= nums[i]) {
                q.pop_back();
            }
            
            // 3. 将当前元素的索引加入队尾
            q.push_back(i);
            
            // 4. 当窗口形成后（即 i >= k - 1），队首元素即为当前窗口的最大值
            if (i >= k - 1) {
                ans.push_back(nums[q.front()]);
            }
        }
        return ans;
    }
};
```

## 5\. 解法简单分析

| 解法 | 时间复杂度 | 空间复杂度 | 优缺点分析 |
| :--- | :--- | :--- | :--- |
| **我的解法 (优先队列)** | $O(n \log n)$ | $O(n)$ | **优点**：思维符合直觉，利用已有数据结构直接求解，逻辑清晰明了。作为大一学生能手写出这种解法说明堆的基础很扎实。<br>**缺点**：最坏情况下（例如数组是单调递增的），所有元素都会一直留在堆中，导致每次 push 的时间复杂度达到 $O(\log n)$，总空间也会退化到 $O(n)$。 |
| **官方解法 (单调队列)** | $O(n)$ | $O(k)$ | **优点**：极致的性能。每个元素的索引最多被 push 进队列一次，也最多被 pop 出队列一次，平摊到每一步的时间复杂度是 $O(1)$，总时间 $O(n)$。空间上只需要维护大小最多为 $k$ 的队列。<br>**缺点**：需要理解并构造单调性，思维跳跃比优先队列略大一点。 |

## 6\. 总结
在后续的刷题过程中，建议将“单调队列”这个概念纳入你的知识体系。在处理“滑动窗口内的极值”这类问题时，单调队列往往是达到 $O(n)$ 最优解的标准答案。理解了为什么可以“提前剔除不可能成为最大值的元素”，会对以后学习其他高级数据结构和贪心算法有很大帮助。